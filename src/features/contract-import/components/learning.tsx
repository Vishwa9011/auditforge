export function Learning() {
    const data = {
        status: '1',
        message: 'OK',
        result: [
            {
                SourceCode:
                    '{{\r\n  "language": "Solidity",\r\n  "sources": {\r\n    "src/UpDownPrediction.sol": {\r\n      "content": "// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.20;\\n\\nimport { Types } from \\"libraries/Types.sol\\";\\nimport { UserManager } from \\"core/UserManager.sol\\";\\nimport { RoundManager } from \\"core/RoundManager.sol\\";\\nimport { CalculatorHelper } from \\"libraries/CalculatorHelper.sol\\";\\nimport { Events } from \\"utils/Events.sol\\";\\nimport { SafeERC20 } from \\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\";\\nimport { IERC20 } from \\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\";\\nimport { AdminControl } from \\"access/AdminControl.sol\\";\\nimport { EmergencyPause } from \\"access/EmergencyPause.sol\\";\\nimport { ReentrancyGuard } from \\"access/ReentrancyGaurd.sol\\";\\n\\ncontract UpDownPrediction is AdminControl, RoundManager, UserManager, EmergencyPause, ReentrancyGuard {\\n    using CalculatorHelper for *;\\n    using SafeERC20 for IERC20;\\n\\n    IERC20 public token;\\n    uint256 public feePercentage = 1; // fee percentage 10%\\n    uint256 public sellFeePercentage = 1; // sell fee percentage 5%\\n    uint256 public constant MAX_FEE_PERCENTAGE = 20; // 20% maximum fee\\n\\n    constructor(address adminAddress, address tokenAddress) AdminControl(adminAddress) EmergencyPause(adminAddress) {\\n        require(tokenAddress != address(0), \\"Invalid token address\\");\\n        token = IERC20(tokenAddress);\\n    }\\n\\n    function setTokenAddress(address tokenAddress) external onlyAdmin {\\n        require(tokenAddress != address(0), \\"Invalid token address\\");\\n        token = IERC20(tokenAddress);\\n    }\\n\\n    function setFeePercentage(uint256 newFeePercentage) external onlyAdmin {\\n        require(newFeePercentage <= MAX_FEE_PERCENTAGE, \\"Fee exceeds maximum\\");\\n        feePercentage = newFeePercentage;\\n    }\\n\\n    function setSellFeePercentage(uint256 newSellFeePercentage) external onlyAdmin {\\n        require(newSellFeePercentage <= MAX_FEE_PERCENTAGE, \\"Sell fee exceeds maximum\\");\\n        sellFeePercentage = newSellFeePercentage;\\n    }\\n\\n    function withdrawToken(uint256 amount, address to) external onlyAdmin nonReentrant {\\n        require(to != address(0), \\"Invalid recipient address\\");\\n        require(amount > 0, \\"Amount must be greater than zero\\");\\n        token.safeTransfer(to, amount);\\n    }\\n\\n    function withdrawETH(uint256 amount, address payable to) external onlyAdmin nonReentrant {\\n        require(to != address(0), \\"Invalid recipient address\\");\\n        require(amount > 0, \\"Amount must be greater than zero\\");\\n        require(address(this).balance >= amount, \\"Insufficient ETH balance\\");\\n\\n        (bool success, ) = to.call{ value: amount }(\\"\\");\\n        require(success, \\"ETH transfer failed\\");\\n    }\\n\\n    /**\\n     * @notice Receive ETH\\n     */\\n    receive() external payable {}\\n\\n    function _getRound(uint256 roundId) internal view override(RoundManager, UserManager) returns (Types.Round memory) {\\n        return _rounds[roundId];\\n    }\\n\\n    function placeBet(uint256 roundId, uint256 amount, Types.Direction direction) external onlyWhenNotPaused {\\n        Types.Round storage round = _rounds[roundId];\\n\\n        _validateBetInput(round, amount, direction);\\n\\n        uint256 betIndex = _roundBets[roundId].length;\\n        uint256 tradeIndex = userTradeHistory[msg.sender].length;\\n\\n        round.totalPool += amount;\\n        if (direction == Types.Direction.UP) {\\n            round.upPool += amount;\\n        } else if (direction == Types.Direction.DOWN) {\\n            round.downPool += amount;\\n        }\\n        uint256 multiplier = _recordBet(round, amount, direction, tradeIndex, feePercentage);\\n\\n        _registerUserAndUpdateStats(msg.sender, amount);\\n\\n        // Record trade in user history\\n        _addTradeHistory(msg.sender, roundId, amount, direction, multiplier, betIndex);\\n\\n        token.safeTransferFrom(msg.sender, address(this), amount);\\n    }\\n\\n    function _validateBetInput(Types.Round storage round, uint256 amount, Types.Direction direction) internal view {\\n        require(round.created, \\"Round does not exist\\");\\n        require(round.startPrice == 0, \\"Betting has ended for this round\\");\\n        require(amount >= round.minBetAmount && amount <= round.maxBetAmount, \\"Amount out of bounds\\");\\n        require(_roundBets[round.round].length < round.betsLimit, \\"Bets limit reached\\");\\n        require(direction == Types.Direction.UP || direction == Types.Direction.DOWN, \\"Invalid direction\\");\\n    }\\n\\n    function startRound(\\n        uint256 roundId,\\n        Types.RoundStartParams calldata params\\n    ) external onlyOperator onlyWhenNotPaused {\\n        _startRound(roundId, params);\\n    }\\n\\n    function createRound(Types.NewRound calldata newRound) external onlyOperator onlyWhenNotPaused {\\n        _currentRoundId += 1;\\n        _createRound(_currentRoundId, newRound);\\n    }\\n\\n    function endRound(\\n        uint256 roundId,\\n        uint256 endPrice,\\n        uint256 batchSize\\n    ) external onlyOperator onlyWhenNotPaused nonReentrant {\\n        require(batchSize > 0, \\"Batch size must be greater than zero\\");\\n\\n        // Determine winner and process distribution batch\\n        Types.Direction winDirection = _endRound(roundId, endPrice);\\n        Types.DistributionResult[] memory results = _processDistributionBatch(\\n            roundId,\\n            winDirection,\\n            batchSize,\\n            feePercentage\\n        );\\n\\n        // Process payouts and update stats\\n        _processPayouts(roundId, results, _isRefundScenario(winDirection));\\n\\n        // Collect project fee if all distributions are complete\\n        _collectProjectFeeIfComplete(roundId);\\n    }\\n\\n    function _processPayouts(uint256 roundId, Types.DistributionResult[] memory results, bool isRefund) private {\\n        if (results.length == 0) return;\\n\\n        (uint256 startIndex, uint256 endIndex) = _getDistributionMetadata(roundId, results.length);\\n        uint256 totalDistributed = 0;\\n        uint256 recipientCount = 0;\\n\\n        for (uint256 i = 0; i < results.length; i++) {\\n            Types.DistributionResult memory result = results[i];\\n\\n            if (_isValidDistribution(result)) {\\n                token.safeTransfer(result.user, result.amount);\\n\\n                _updateUserStats(result.user, 0, true, result.amount);\\n\\n                totalDistributed += result.amount;\\n                recipientCount++;\\n            }\\n        }\\n\\n        if (recipientCount > 0) {\\n            emit Events.BatchDistributed(\\n                roundId,\\n                startIndex,\\n                endIndex,\\n                totalDistributed,\\n                recipientCount,\\n                isRefund,\\n                block.timestamp\\n            );\\n        }\\n    }\\n\\n    function _collectProjectFeeIfComplete(uint256 roundId) private {\\n        if (!isDistributionComplete(roundId)) return;\\n\\n        Types.Round storage round = _rounds[roundId];\\n        uint256 projectFee = CalculatorHelper.calculateFee(round.totalPool, feePercentage);\\n\\n        token.safeTransfer(owner(), projectFee);\\n        emit Events.FeeCollected(roundId, projectFee, block.timestamp);\\n    }\\n\\n    function sellPosition(uint256 roundId, uint256 betIndex) external onlyWhenNotPaused nonReentrant {\\n        (uint256 sellAmount, uint256 sellFee, uint256 tradeIndex) = _sellPosition(\\n            roundId,\\n            betIndex,\\n            feePercentage,\\n            sellFeePercentage\\n        );\\n        _updateUserTrade(msg.sender, tradeIndex, true, sellAmount);\\n        _updateUserStats(msg.sender, 0, true, sellAmount);\\n\\n        token.safeTransfer(msg.sender, sellAmount);\\n        token.safeTransfer(owner(), sellFee);\\n    }\\n\\n    /**\\n     * @notice Get pending result rounds\\n     * @return Array of rounds pending result declaration\\n     */\\n    function getPendingResultRounds() external view returns (Types.Round[] memory) {\\n        return _getPendingResultRounds();\\n    }\\n\\n    /**\\n     * @notice Get user trade history with offset-based pagination\\n     * @param user The user address\\n     * @param offset The starting index (0-based)\\n     * @param limit The number of trades to return (max 100)\\n     * @return Array of trade history views\\n     */\\n    function getUserTradeHistory(\\n        address user,\\n        uint256 offset,\\n        uint256 limit\\n    ) external view returns (Types.TradeHistoryView[] memory) {\\n        return _getUserTradeHistory(user, offset, limit, feePercentage);\\n    }\\n\\n    /**\\n     * @notice Get active bets for a specific user in the current round\\n     * @param user The user address to filter bets for\\n     * @return Array of bet views with current multipliers and values\\n     */\\n    function getActiveBetsForUser(address user) external view returns (Types.BetView[] memory) {\\n        return getActiveBetsForUserInRound(_currentRoundId, user);\\n    }\\n\\n    /**\\n     * @notice Get active bets for a specific user in a specific round\\n     * @param roundId The round ID to query\\n     * @param user The user address to filter bets for\\n     * @return Array of bet views with current multipliers and values\\n     */\\n    function getActiveBetsForUserInRound(uint256 roundId, address user) public view returns (Types.BetView[] memory) {\\n        return _getActiveBetsForUser(roundId, user, feePercentage, sellFeePercentage);\\n    }\\n\\n    /**\\n     * @notice Get active trades for a specific user across all _rounds\\n     * @param user The user address\\n     * @return Array of active trade history views\\n     */\\n    function getUserActiveTrades(address user) external view returns (Types.TradeHistoryView[] memory) {\\n        return _getUserActiveTrades(user, feePercentage);\\n    }\\n\\n    /**\\n     * @notice Get all trades for a specific user in a specific round\\n     * @param user The user address\\n     * @param roundId The round ID to filter by\\n     * @return Array of trade history views for the round\\n     */\\n    function getUserTradesByRound(\\n        address user,\\n        uint256 roundId\\n    ) external view returns (Types.TradeHistoryView[] memory) {\\n        return _getUserTradesByRound(user, roundId, feePercentage);\\n    }\\n\\n    /**\\n     * @notice Get leaderboard of top users by total amount won\\n     * @param limit Maximum number of users to return (max 100)\\n     * @return Array of user stats sorted by totalAmountWon (each includes user address)\\n     */\\n    function getLeaderboard(uint256 limit) external view returns (Types.UserStats[] memory) {\\n        require(limit > 0 && limit <= 100, \\"Limit must be between 1 and 100\\");\\n        return _getLeaderboard(limit);\\n    }\\n\\n    /**\\n     * @notice Get user statistics\\n     * @param user The user address\\n     * @return User statistics struct\\n     */\\n    function getUserStats(address user) external view returns (Types.UserStats memory) {\\n        return _getUserStats(user);\\n    }\\n\\n    /**\\n     * @notice Get total number of registered users\\n     * @return Total user count\\n     */\\n    function getTotalUsers() external view returns (uint256) {\\n        return _getTotalUsers();\\n    }\\n\\n    /**\\n     * @notice Get current round ID\\n     * @return uint256 current round ID\\n     */\\n    function getCurrentRoundId() external view returns (uint256) {\\n        return _currentRoundId;\\n    }\\n\\n    /**\\n     * @notice Get complete round information by ID\\n     * @param roundId The round ID to query\\n     * @return Round struct with all details\\n     */\\n    function getRound(uint256 roundId) external view returns (Types.Round memory) {\\n        require(_rounds[roundId].created, \\"Round does not exist\\");\\n        return _rounds[roundId];\\n    }\\n\\n    /**\\n     * @notice Get current active round information\\n     * @return Current round struct\\n     */\\n    function getCurrentRound() external view returns (Types.Round memory) {\\n        require(_rounds[_currentRoundId].created, \\"No active round\\");\\n        return _rounds[_currentRoundId];\\n    }\\n\\n    /**\\n     * @notice Get all bets for a specific round\\n     * @param roundId The round ID\\n     * @return Array of all bets\\n     */\\n    function getRoundBets(uint256 roundId) external view returns (Types.Bet[] memory) {\\n        require(_rounds[roundId].created, \\"Round does not exist\\");\\n        return _roundBets[roundId];\\n    }\\n\\n    /**\\n     * @notice Get bet count for a round\\n     * @param roundId The round ID\\n     * @return Total number of bets\\n     */\\n    function getRoundBetCount(uint256 roundId) external view returns (uint256) {\\n        require(_rounds[roundId].created, \\"Round does not exist\\");\\n        return _roundBets[roundId].length;\\n    }\\n\\n    /**\\n     * @notice Get specific bet details\\n     * @param roundId The round ID\\n     * @param betIndex The bet index\\n     * @return Bet struct\\n     */\\n    function getBet(uint256 roundId, uint256 betIndex) external view returns (Types.Bet memory) {\\n        require(_rounds[roundId].created, \\"Round does not exist\\");\\n        require(betIndex < _roundBets[roundId].length, \\"Bet index out of bounds\\");\\n        return _roundBets[roundId][betIndex];\\n    }\\n\\n    /**\\n     * @notice Get the result of a round\\n     * @param roundId The round ID\\n     * @return Direction enum indicating UP or DOWN\\n     */\\n    function getResult(uint256 roundId) external view returns (Types.Direction) {\\n        return _getResult(roundId);\\n    }\\n\\n    /**\\n     * @notice Get pool information for a round\\n     * @param roundId The round ID\\n     * @return totalPool Total amount in the pool\\n     * @return upPool Amount in UP pool\\n     * @return downPool Amount in DOWN pool\\n     * @return upMultiplier Current multiplier for UP bets\\n     * @return downMultiplier Current multiplier for DOWN bets\\n     */\\n    function getRoundPools(\\n        uint256 roundId\\n    )\\n        external\\n        view\\n        returns (uint256 totalPool, uint256 upPool, uint256 downPool, uint256 upMultiplier, uint256 downMultiplier)\\n    {\\n        require(_rounds[roundId].created, \\"Round does not exist\\");\\n        Types.Round memory round = _rounds[roundId];\\n\\n        totalPool = round.totalPool;\\n        upPool = round.upPool;\\n        downPool = round.downPool;\\n\\n        upMultiplier = CalculatorHelper.calculateRewardMultiplier(totalPool, upPool, feePercentage);\\n        downMultiplier = CalculatorHelper.calculateRewardMultiplier(totalPool, downPool, feePercentage);\\n    }\\n\\n    /**\\n     * @notice Get distribution status for a round\\n     * @param roundId The round ID\\n     * @return isComplete Whether distribution is complete\\n     * @return distributedCount Number of bets distributed\\n     * @return totalBets Total number of bets\\n     * @return totalDistributed Total amount distributed\\n     */\\n    function getDistributionStatus(\\n        uint256 roundId\\n    ) external view returns (bool isComplete, uint256 distributedCount, uint256 totalBets, uint256 totalDistributed) {\\n        require(_rounds[roundId].created, \\"Round does not exist\\");\\n        Types.Round memory round = _rounds[roundId];\\n\\n        totalBets = _roundBets[roundId].length;\\n        distributedCount = round.distributedCount;\\n        totalDistributed = round.totalDistributed;\\n        isComplete = distributedCount >= totalBets;\\n    }\\n\\n    /**\\n     * @notice Get pending distribution count\\n     * @param roundId The round ID\\n     * @return Number of bets pending distribution\\n     */\\n    function getPendingDistribution(uint256 roundId) external view returns (uint256) {\\n        require(_rounds[roundId].created, \\"Round does not exist\\");\\n        uint256 totalBets = _roundBets[roundId].length;\\n        uint256 distributed = _rounds[roundId].distributedCount;\\n        return totalBets > distributed ? totalBets - distributed : 0;\\n    }\\n\\n    /**\\n     * @notice Get contract configuration\\n     * @return tokenAddress The token used for betting\\n     * @return feePercent Current fee percentage\\n     * @return sellFeePercent Current sell fee percentage\\n     * @return maxFeePercent Maximum allowed fee percentage\\n     */\\n    function getConfiguration()\\n        external\\n        view\\n        returns (address tokenAddress, uint256 feePercent, uint256 sellFeePercent, uint256 maxFeePercent)\\n    {\\n        tokenAddress = address(token);\\n        feePercent = feePercentage;\\n        sellFeePercent = sellFeePercentage;\\n        maxFeePercent = MAX_FEE_PERCENTAGE;\\n    }\\n\\n    /**\\n     * @notice Calculate potential payout for a bet\\n     * @param roundId The round ID\\n     * @param amount The bet amount\\n     * @param direction The bet direction\\n     * @return potentialPayout The potential payout if the bet wins\\n     * @return currentMultiplier The current multiplier for the direction\\n     */\\n    function calculatePotentialPayout(\\n        uint256 roundId,\\n        uint256 amount,\\n        Types.Direction direction\\n    ) external view returns (uint256 potentialPayout, uint256 currentMultiplier) {\\n        require(_rounds[roundId].created, \\"Round does not exist\\");\\n        Types.Round memory round = _rounds[roundId];\\n\\n        uint256 directionPool = CalculatorHelper.determineDirectionPool(round, direction);\\n\\n        currentMultiplier = CalculatorHelper.calculateRewardMultiplier(round.totalPool, directionPool, feePercentage);\\n\\n        potentialPayout = CalculatorHelper.calculateRewardAmount(\\n            amount,\\n            round.totalPool + amount,\\n            directionPool + amount,\\n            feePercentage\\n        );\\n    }\\n}\\n"\r\n    },\r\n    "src/libraries/Types.sol": {\r\n      "content": "// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.20;\\n\\nlibrary Types {\\n    enum Direction {\\n        DEFAULT,\\n        UP,\\n        DOWN,\\n        DRAW\\n    }\\n\\n    enum TradeStatus {\\n        ACTIVE, // Bet placed, round not ended yet\\n        WON, // User won the round\\n        LOST, // User lost the round\\n        REFUNDED, // Draw or no opposition, bet refunded\\n        SOLD // Early exit (for future implementation)\\n    }\\n\\n    struct NewRound {\\n        uint256 minBetAmount;\\n        uint256 maxBetAmount;\\n        uint256 betsLimit;\\n    }\\n\\n    struct RoundStartParams {\\n        uint256 startPrice;\\n        uint256 startTime;\\n        uint256 endTime;\\n    }\\n\\n    struct Round {\\n        uint256 round;\\n        uint256 startPrice;\\n        uint256 endPrice;\\n        uint256 minBetAmount; // Minimum bet amount for the round\\n        uint256 maxBetAmount; // Maximum bet amount for the round\\n        uint256 totalPool; // Total amount bet in the round\\n        uint256 upPool; // Total amount bet on Up\\n        uint256 downPool; // Total amount bet on Down\\n        Direction result; // Result of the round\\n        uint256 startTime;\\n        uint256 endTime;\\n        uint256 distributedCount; // Number of bets that have been distributed rewards\\n        uint256 totalDistributed; // Total amount distributed as rewards\\n        uint256 betsLimit; // Maximum number of bets allowed in the round\\n        bool created;\\n        uint256 createdAt;\\n    }\\n\\n    struct Bet {\\n        address user; // Address of the user who placed the bet\\n        uint256 tradeIndex; // Index of the trade in user\'s trade history\\n        uint256 amount; // Amount of the bet\\n        Direction direction; // Direction of the bet (UP or DOWN)\\n        bool sold; // Whether the bet has been sold\\n        uint256 sellAmount; // Amount for which the bet was sold\\n        uint256 entryMultiplier; // Multiplier at the time of bet placement\\n    }\\n\\n    struct UserStats {\\n        address user;\\n        uint256 totalBets;\\n        uint256 totalWins;\\n        uint256 totalAmountBet;\\n        uint256 totalAmountWon;\\n        bool exists;\\n    }\\n\\n    struct Distribution {\\n        uint256 projectFee;\\n        uint256 netPool; // Total pool after deducting fees\\n        uint256 pendingDistribution;\\n    }\\n\\n    struct DistributionResult {\\n        address user;\\n        uint256 amount;\\n    }\\n\\n    struct TradeHistory {\\n        uint256 roundId; // Round identifier\\n        uint256 amount; // Bet amount\\n        Direction direction; // UP or DOWN\\n        uint256 entryMultiplier; // Multiplier at bet placement\\n        uint256 timestamp; // When bet was placed\\n        bool sold; // Whether the bet was sold\\n        uint256 sellAmount; // Amount received from selling (0 if not sold)\\n        uint256 betIndex; // Index of the bet in the round/user\'s bets\\n    }\\n\\n    struct TradeHistoryView {\\n        uint256 roundId; // Round identifier\\n        uint256 amount; // Bet amount\\n        Direction direction; // UP or DOWN\\n        Direction result; // Result of the round\\n        uint256 entryMultiplier; // Multiplier at bet placement\\n        uint256 timestamp; // When bet was placed\\n        uint256 betIndex; // Index of the bet in the round/user\'s bets\\n        TradeStatus status; // Calculated status\\n        uint256 payout; // Calculated payout\\n        uint256 startPrice; // Round start price\\n        uint256 endPrice; // Round end price\\n    }\\n\\n    struct BetView {\\n        uint256 tradeIndex; // Index of the trade in user\'s trade history\\n        uint256 betIndex; // Index of the bet in the round\\n        address user; // User who placed the bet\\n        uint256 amount; // Bet amount\\n        Direction direction; // UP or DOWN\\n        bool sold; // Whether the bet was sold\\n        uint256 sellAmount; // Amount received from selling (0 if not sold)\\n        uint256 entryMultiplier; // Multiplier at bet placement\\n        uint256 currentMultiplier; // Current multiplier for the bet direction\\n        uint256 currentValue; // Current estimated value if sold now\\n    }\\n}\\n"\r\n    },\r\n    "src/core/UserManager.sol": {\r\n      "content": "// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.20;\\n\\nimport { Types } from \\"libraries/Types.sol\\";\\nimport { CalculatorHelper } from \\"libraries/CalculatorHelper.sol\\";\\n\\nabstract contract UserManager {\\n    constructor() {}\\n\\n    address[] internal users;\\n    mapping(address => Types.UserStats) internal userStats;\\n    mapping(address => Types.TradeHistory[]) internal userTradeHistory;\\n\\n    function _registerUser(address user) internal {\\n        if (!userStats[user].exists) {\\n            userStats[user] = Types.UserStats({\\n                user: user,\\n                totalBets: 0,\\n                totalWins: 0,\\n                totalAmountBet: 0,\\n                totalAmountWon: 0,\\n                exists: true\\n            });\\n            users.push(user);\\n        }\\n    }\\n\\n    function _getUserStats(address user) internal view returns (Types.UserStats memory) {\\n        return userStats[user];\\n    }\\n\\n    function _updateUserStats(address user, uint256 amountBet, bool won, uint256 amountWon) internal {\\n        Types.UserStats storage stats = userStats[user];\\n        if (amountBet > 0) {\\n            stats.totalBets += 1;\\n            stats.totalAmountBet += amountBet;\\n        } else if (won) {\\n            stats.totalWins += 1;\\n            stats.totalAmountWon += amountWon;\\n        }\\n    }\\n\\n    function _updateUserTrade(address user, uint256 tradeIndex, bool sold, uint256 sellAmount) internal {\\n        Types.TradeHistory storage trade = userTradeHistory[user][tradeIndex];\\n        trade.sold = sold;\\n        trade.sellAmount = sellAmount;\\n    }\\n\\n    function _registerUserAndUpdateStats(address user, uint256 amount) internal {\\n        _registerUser(user);\\n        _updateUserStats(user, amount, false, 0);\\n    }\\n\\n    function _addTradeHistory(\\n        address user,\\n        uint256 roundId,\\n        uint256 amount,\\n        Types.Direction direction,\\n        uint256 multiplier,\\n        uint256 betIndex\\n    ) internal {\\n        userTradeHistory[user].push(\\n            Types.TradeHistory({\\n                roundId: roundId,\\n                amount: amount,\\n                direction: direction,\\n                betIndex: betIndex,\\n                entryMultiplier: multiplier,\\n                timestamp: block.timestamp,\\n                sold: false,\\n                sellAmount: 0\\n            })\\n        );\\n    }\\n\\n    function _getRound(uint256 roundId) internal view virtual returns (Types.Round memory);\\n\\n    function _calculateTradeView(\\n        Types.TradeHistory memory trade,\\n        uint256 feePercentage\\n    ) internal view returns (Types.TradeHistoryView memory) {\\n        Types.Round memory round = _getRound(trade.roundId);\\n\\n        // Calculate status\\n        Types.TradeStatus status = CalculatorHelper.determineTradeStatus(trade, round);\\n        uint256 payout = 0;\\n\\n        if (trade.sold) {\\n            payout = trade.sellAmount;\\n        } else if (round.endPrice > 0) {\\n            // Round has ended\\n            if (round.result == Types.Direction.DRAW) {\\n                payout = CalculatorHelper.calculateNetAmount(trade.amount, feePercentage);\\n            } else if (trade.direction == round.result) {\\n                // User won\\n                uint256 winningPool = round.result == Types.Direction.UP ? round.upPool : round.downPool;\\n                payout = CalculatorHelper.calculateRewardAmount(\\n                    trade.amount,\\n                    round.totalPool,\\n                    winningPool,\\n                    feePercentage\\n                );\\n            } else {\\n                // User lost\\n                status = Types.TradeStatus.LOST;\\n                payout = 0;\\n            }\\n        }\\n\\n        return\\n            Types.TradeHistoryView({\\n                roundId: trade.roundId,\\n                amount: trade.amount,\\n                betIndex: trade.betIndex,\\n                direction: trade.direction,\\n                entryMultiplier: trade.entryMultiplier,\\n                timestamp: trade.timestamp,\\n                status: status,\\n                payout: payout,\\n                result: round.result,\\n                startPrice: round.startPrice,\\n                endPrice: round.endPrice\\n            });\\n    }\\n\\n    /**\\n     * @notice Get user trade history with offset-based pagination (newest first)\\n     * @param user The user address\\n     * @param offset The starting index (0-based, from newest)\\n     * @param limit The number of trades to return (max 100)\\n     * @param feePercentage The fee percentage for payout calculation\\n     * @return Array of trade history views (newest first)\\n     */\\n    function _getUserTradeHistory(\\n        address user,\\n        uint256 offset,\\n        uint256 limit,\\n        uint256 feePercentage\\n    ) internal view returns (Types.TradeHistoryView[] memory) {\\n        require(limit > 0 && limit <= 100, \\"Limit must be between 1 and 100\\");\\n\\n        Types.TradeHistory[] storage allTrades = userTradeHistory[user];\\n        uint256 total = allTrades.length;\\n\\n        if (offset >= total) {\\n            return new Types.TradeHistoryView[](0);\\n        }\\n\\n        uint256 end = offset + limit > total ? total : offset + limit;\\n        uint256 size = end - offset;\\n\\n        Types.TradeHistoryView[] memory trades = new Types.TradeHistoryView[](size);\\n        for (uint256 i = 0; i < size; i++) {\\n            trades[i] = _calculateTradeView(allTrades[total - 1 - offset - i], feePercentage);\\n        }\\n\\n        return trades;\\n    }\\n\\n    function getUserTradeCount(address user) external view returns (uint256) {\\n        return userTradeHistory[user].length;\\n    }\\n\\n    function _getUserActiveTrades(\\n        address user,\\n        uint256 feePercentage\\n    ) internal view returns (Types.TradeHistoryView[] memory) {\\n        Types.TradeHistory[] storage allTrades = userTradeHistory[user];\\n        uint256 total = allTrades.length;\\n\\n        // Count active trades first\\n        uint256 activeCount = 0;\\n        for (uint256 i = 0; i < total; i++) {\\n            Types.Round memory round = _getRound(allTrades[i].roundId);\\n            if (round.endPrice == 0) {\\n                activeCount++;\\n            }\\n        }\\n\\n        // Build result array\\n        Types.TradeHistoryView[] memory activeTrades = new Types.TradeHistoryView[](activeCount);\\n        uint256 index = 0;\\n        for (uint256 i = 0; i < total; i++) {\\n            Types.Round memory round = _getRound(allTrades[i].roundId);\\n            if (round.endPrice == 0) {\\n                activeTrades[index] = _calculateTradeView(allTrades[i], feePercentage);\\n                index++;\\n            }\\n        }\\n\\n        return activeTrades;\\n    }\\n\\n    function _getUserTradesByRound(\\n        address user,\\n        uint256 roundId,\\n        uint256 feePercentage\\n    ) internal view returns (Types.TradeHistoryView[] memory) {\\n        Types.TradeHistory[] storage allTrades = userTradeHistory[user];\\n        uint256 total = allTrades.length;\\n\\n        // Count trades for this round\\n        uint256 roundTradeCount = 0;\\n        for (uint256 i = 0; i < total; i++) {\\n            if (allTrades[i].roundId == roundId) {\\n                roundTradeCount++;\\n            }\\n        }\\n\\n        // Build result array\\n        Types.TradeHistoryView[] memory roundTrades = new Types.TradeHistoryView[](roundTradeCount);\\n        uint256 index = 0;\\n        for (uint256 i = 0; i < total; i++) {\\n            if (allTrades[i].roundId == roundId) {\\n                roundTrades[index] = _calculateTradeView(allTrades[i], feePercentage);\\n                index++;\\n            }\\n        }\\n\\n        return roundTrades;\\n    }\\n\\n    /**\\n     * @notice Get leaderboard of top users by total amount won\\n     * @param limit Maximum number of users to return\\n     * @return Array of user stats sorted by winnings (includes user address in each struct)\\n     */\\n    function _getLeaderboard(uint256 limit) internal view returns (Types.UserStats[] memory) {\\n        uint256 totalUsers = users.length;\\n        uint256 resultSize = limit > totalUsers ? totalUsers : limit;\\n\\n        if (totalUsers == 0) {\\n            return new Types.UserStats[](0);\\n        }\\n\\n        // Copy all users to temporary array for sorting\\n        Types.UserStats[] memory tempStats = new Types.UserStats[](totalUsers);\\n        for (uint256 i = 0; i < totalUsers; i++) {\\n            tempStats[i] = userStats[users[i]];\\n        }\\n\\n        // Selection sort - find top N users by total amount won\\n        for (uint256 i = 0; i < resultSize; i++) {\\n            uint256 maxIndex = i;\\n            uint256 maxWonAmount = tempStats[i].totalAmountWon;\\n\\n            // Find user with highest winnings in remaining array\\n            for (uint256 j = i + 1; j < totalUsers; j++) {\\n                if (tempStats[j].totalAmountWon > maxWonAmount) {\\n                    maxWonAmount = tempStats[j].totalAmountWon;\\n                    maxIndex = j;\\n                }\\n            }\\n\\n            // Swap if we found a user with higher winnings\\n            if (maxIndex != i) {\\n                Types.UserStats memory temp = tempStats[i];\\n                tempStats[i] = tempStats[maxIndex];\\n                tempStats[maxIndex] = temp;\\n            }\\n        }\\n\\n        // Return only top N results\\n        Types.UserStats[] memory leaderboard = new Types.UserStats[](resultSize);\\n        for (uint256 i = 0; i < resultSize; i++) {\\n            leaderboard[i] = tempStats[i];\\n        }\\n\\n        return leaderboard;\\n    }\\n\\n    /**\\n     * @notice Get total number of registered users\\n     * @return Total user count\\n     */\\n    function _getTotalUsers() internal view returns (uint256) {\\n        return users.length;\\n    }\\n}\\n"\r\n    },\r\n    "src/core/RoundManager.sol": {\r\n      "content": "// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.20;\\n\\nimport { Types } from \\"libraries/Types.sol\\";\\nimport { Events } from \\"utils/Events.sol\\";\\nimport { CalculatorHelper } from \\"libraries/CalculatorHelper.sol\\";\\n\\nabstract contract RoundManager {\\n    uint256 internal _currentRoundId;\\n    mapping(uint256 => Types.Round) internal _rounds;\\n    mapping(uint256 => Types.Bet[]) internal _roundBets;\\n\\n    function _getRound(uint256 roundId) internal view virtual returns (Types.Round memory) {\\n        return _rounds[roundId];\\n    }\\n\\n    function _createRound(uint256 roundId, Types.NewRound calldata newRound) internal {\\n        require(!_rounds[roundId].created, \\"Round already exists\\");\\n        _rounds[roundId] = Types.Round({\\n            round: roundId,\\n            startPrice: 0,\\n            endPrice: 0,\\n            minBetAmount: newRound.minBetAmount,\\n            maxBetAmount: newRound.maxBetAmount,\\n            totalPool: 0,\\n            upPool: 0,\\n            downPool: 0,\\n            result: Types.Direction.DEFAULT, // default value\\n            startTime: 0,\\n            endTime: 0,\\n            distributedCount: 0,\\n            totalDistributed: 0,\\n            betsLimit: newRound.betsLimit,\\n            created: true,\\n            createdAt: block.timestamp\\n        });\\n\\n        emit Events.RoundCreated(roundId, block.timestamp);\\n    }\\n\\n    function _startRound(uint256 roundId, Types.RoundStartParams calldata params) internal {\\n        uint256 startPrice = params.startPrice;\\n\\n        require(_rounds[roundId].created, \\"Round does not exist\\");\\n        require(params.startTime < params.endTime, \\"Invalid round time\\");\\n        require(startPrice > 0, \\"Start price must be greater than zero\\");\\n\\n        Types.Round storage round = _rounds[roundId];\\n        round.startPrice = startPrice;\\n        round.startTime = params.startTime;\\n        round.endTime = params.endTime;\\n\\n        emit Events.RoundStarted(roundId, startPrice, params.startTime, params.endTime, block.timestamp);\\n    }\\n\\n    function _endRound(uint256 roundId, uint256 endPrice) internal returns (Types.Direction) {\\n        Types.Round storage round = _rounds[roundId];\\n        require(round.created, \\"Round does not exist\\");\\n        require(round.startPrice > 0, \\"Round has not started\\");\\n        require(endPrice > 0, \\"End price must be greater than zero\\");\\n\\n        // Set the end price\\n        round.endPrice = endPrice;\\n\\n        // distribute rewards\\n        Types.Direction winDirection = CalculatorHelper.determineRoundResult(round);\\n\\n        // Set the round result\\n        round.result = winDirection;\\n\\n        emit Events.RoundEnded(roundId, endPrice, winDirection, block.timestamp);\\n\\n        return winDirection;\\n    }\\n\\n    function _sellPosition(\\n        uint256 roundId,\\n        uint256 betIndex,\\n        uint256 feePercentage,\\n        uint256 sellFeePercentage\\n    ) internal returns (uint256 sellAmount, uint256 totalFee, uint256 tradeIndex) {\\n        Types.Round storage round = _rounds[roundId];\\n        Types.Bet storage bet = _roundBets[roundId][betIndex];\\n        tradeIndex = bet.tradeIndex;\\n\\n        require(bet.user == msg.sender, \\"Not bet owner\\");\\n        require(!bet.sold, \\"Bet already sold\\");\\n        require(round.created, \\"Round does not exist\\");\\n        require(block.timestamp < round.endTime, \\"Round has ended\\");\\n        require(round.endPrice == 0, \\"Round has ended\\");\\n\\n        uint256 currentMultiplier;\\n        (sellAmount, totalFee, currentMultiplier) = CalculatorHelper.calculateSellOutcome(\\n            round,\\n            bet,\\n            feePercentage,\\n            sellFeePercentage\\n        );\\n\\n        bet.sold = true;\\n        bet.sellAmount = sellAmount;\\n        uint256 totalPoolReduction = sellAmount + totalFee; // to insure total deduction from pools\\n\\n        // This ensures multipliers remain accurate for remaining bets\\n        round.totalPool -= totalPoolReduction;\\n        if (bet.direction == Types.Direction.UP) {\\n            round.upPool -= totalPoolReduction;\\n        } else {\\n            round.downPool -= totalPoolReduction;\\n        }\\n\\n        emit Events.BetSold(\\n            roundId,\\n            msg.sender,\\n            betIndex,\\n            bet.amount,\\n            sellAmount,\\n            bet.entryMultiplier,\\n            currentMultiplier,\\n            block.timestamp\\n        );\\n    }\\n\\n    function _processDistributionBatch(\\n        uint256 roundId,\\n        Types.Direction winDirection,\\n        uint256 batchSize,\\n        uint256 feePercentage\\n    ) internal returns (Types.DistributionResult[] memory) {\\n        Types.Bet[] storage bets = _roundBets[roundId];\\n        Types.Round storage round = _rounds[roundId];\\n\\n        // Calculate batch range using helper function\\n        (uint256 start, uint256 end) = _calculateBatchRange(bets.length, round.distributedCount, batchSize);\\n\\n        // Check if refund is needed using helper function\\n        if (_shouldRefundBets(winDirection)) {\\n            return _processRefundBatch(round, bets, start, end, feePercentage);\\n        }\\n\\n        // Get winning pool using helper function\\n        uint256 winningPool = CalculatorHelper.determineDirectionPool(round, winDirection);\\n\\n        Types.DistributionResult[] memory results = new Types.DistributionResult[](end - start);\\n\\n        for (uint256 i = start; i < end; i++) {\\n            Types.Bet storage bet = bets[i];\\n\\n            if (bet.direction == winDirection && !bet.sold) {\\n                uint256 rewardAmount = CalculatorHelper.calculateRewardAmount(\\n                    bet.amount,\\n                    round.totalPool,\\n                    winningPool,\\n                    feePercentage\\n                );\\n\\n                results[i - start] = Types.DistributionResult({ user: bet.user, amount: rewardAmount });\\n\\n                round.totalDistributed += rewardAmount;\\n            }\\n        }\\n\\n        round.distributedCount += (end - start);\\n\\n        return results;\\n    }\\n\\n    function _processRefundBatch(\\n        Types.Round storage round,\\n        Types.Bet[] storage bets,\\n        uint256 start,\\n        uint256 end,\\n        uint256 feePercentage\\n    ) internal returns (Types.DistributionResult[] memory) {\\n        Types.DistributionResult[] memory results = new Types.DistributionResult[](end - start);\\n\\n        for (uint256 i = start; i < end; i++) {\\n            if (bets[i].sold) {\\n                continue;\\n            }\\n\\n            uint256 amountAfterFee = CalculatorHelper.calculateNetAmount(bets[i].amount, feePercentage);\\n\\n            results[i - start] = Types.DistributionResult({ user: bets[i].user, amount: amountAfterFee });\\n\\n            round.totalDistributed += amountAfterFee;\\n        }\\n\\n        // Update distributed count once after loop\\n        round.distributedCount += (end - start);\\n\\n        return results;\\n    }\\n\\n    function _updateRoundPools(Types.Round storage round, uint256 amount, Types.Direction direction) internal {\\n        round.totalPool += amount;\\n        if (direction == Types.Direction.UP) {\\n            round.upPool += amount;\\n        } else if (direction == Types.Direction.DOWN) {\\n            round.downPool += amount;\\n        }\\n    }\\n\\n    function _recordBet(\\n        Types.Round storage round,\\n        uint256 amount,\\n        Types.Direction direction,\\n        uint256 tradeIndex,\\n        uint256 feePercentage\\n    ) internal returns (uint256 currentMultiplier) {\\n        // Select correct pool based on direction\\n        uint256 directionPool = CalculatorHelper.determineDirectionPool(round, direction);\\n\\n        currentMultiplier = CalculatorHelper.calculateRewardMultiplier(round.totalPool, directionPool, feePercentage);\\n\\n        Types.Bet memory newBet = Types.Bet({\\n            user: msg.sender,\\n            amount: amount,\\n            direction: direction,\\n            sold: false,\\n            sellAmount: 0,\\n            tradeIndex: tradeIndex,\\n            entryMultiplier: currentMultiplier\\n        });\\n\\n        _roundBets[round.round].push(newBet);\\n\\n        emit Events.BetPlaced(round.round, msg.sender, amount, direction, currentMultiplier, block.timestamp);\\n\\n        return currentMultiplier;\\n    }\\n\\n    function isDistributionComplete(uint256 roundId) public view returns (bool) {\\n        return _rounds[roundId].distributedCount >= _roundBets[roundId].length;\\n    }\\n\\n    function _checkOppositePoolZero(\\n        Types.Round memory round,\\n        Types.Direction winDirection\\n    ) internal pure returns (bool) {\\n        if (winDirection == Types.Direction.UP && round.downPool == 0) {\\n            return true;\\n        } else if (winDirection == Types.Direction.DOWN && round.upPool == 0) {\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n    function _calculateBatchRange(\\n        uint256 totalBets,\\n        uint256 distributedCount,\\n        uint256 batchSize\\n    ) internal pure returns (uint256 start, uint256 end) {\\n        start = distributedCount;\\n        uint256 pendingDistribution = totalBets - distributedCount;\\n        end = pendingDistribution < batchSize ? totalBets : start + batchSize;\\n    }\\n\\n    function _shouldRefundBets(Types.Direction winDirection) internal pure returns (bool) {\\n        return winDirection == Types.Direction.DRAW;\\n    }\\n\\n    /**\\n     * @notice Get active bets for a specific user in a round\\n     * @param roundId The round ID to query\\n     * @param user The user address to filter bets for\\n     * @param feePercentage The fee percentage for calculating current values\\n     * @return Array of bet views with current multipliers and values\\n     */\\n    function _getActiveBetsForUser(\\n        uint256 roundId,\\n        address user,\\n        uint256 feePercentage,\\n        uint256 sellFeePercentage\\n    ) internal view returns (Types.BetView[] memory) {\\n        Types.Round memory round = _rounds[roundId];\\n        require(round.created, \\"Round does not exist\\");\\n\\n        Types.Bet[] storage bets = _roundBets[roundId];\\n\\n        // First, count active bets for the user\\n        uint256 activeBetCount = 0;\\n        for (uint256 i = 0; i < bets.length; i++) {\\n            if (!bets[i].sold && bets[i].user == user) {\\n                activeBetCount++;\\n            }\\n        }\\n\\n        // Create array with exact size needed\\n        Types.BetView[] memory activeBets = new Types.BetView[](activeBetCount);\\n        uint256 index = 0;\\n\\n        // Populate active bets with current data\\n        for (uint256 i = 0; i < bets.length; i++) {\\n            Types.Bet storage bet = bets[i];\\n\\n            if (!bet.sold && bet.user == user) {\\n                uint256 currentValue = 0;\\n                uint256 currentMultiplier = 0;\\n                // Only calculate current value if round hasn\'t ended\\n                if (round.endPrice == 0 && block.timestamp < round.endTime) {\\n                    (currentValue, , currentMultiplier) = CalculatorHelper.calculateSellOutcome(\\n                        round,\\n                        bet,\\n                        feePercentage,\\n                        sellFeePercentage\\n                    );\\n                }\\n\\n                activeBets[index] = Types.BetView({\\n                    tradeIndex: bet.tradeIndex,\\n                    betIndex: i,\\n                    user: bet.user,\\n                    amount: bet.amount,\\n                    direction: bet.direction,\\n                    sold: bet.sold,\\n                    sellAmount: bet.sellAmount,\\n                    entryMultiplier: bet.entryMultiplier,\\n                    currentMultiplier: currentMultiplier,\\n                    currentValue: currentValue\\n                });\\n\\n                index++;\\n            }\\n        }\\n\\n        return activeBets;\\n    }\\n\\n    /**\\n     * @notice Get the result of a round\\n     */\\n    function _getResult(uint256 roundId) internal view returns (Types.Direction) {\\n        Types.Round memory round = _rounds[roundId];\\n        require(round.created, \\"Round does not exist\\");\\n        require(round.endPrice > 0, \\"Round has not ended\\");\\n        return round.result;\\n    }\\n\\n    /**\\n     * @notice Check if the round result is a refund scenario\\n     */\\n    function _isRefundScenario(Types.Direction winDirection) internal pure returns (bool) {\\n        return winDirection == Types.Direction.DRAW;\\n    }\\n\\n    /**\\n     * @notice Validate if a distribution result is valid for payout\\n     */\\n    function _isValidDistribution(Types.DistributionResult memory result) internal pure returns (bool) {\\n        return result.user != address(0) && result.amount > 0;\\n    }\\n\\n    /**\\n     * @notice Get distribution metadata for batch processing\\n     */\\n    function _getDistributionMetadata(\\n        uint256 roundId,\\n        uint256 resultsLength\\n    ) internal view returns (uint256 startIndex, uint256 endIndex) {\\n        Types.Round storage round = _rounds[roundId];\\n        endIndex = round.distributedCount;\\n        startIndex = endIndex - resultsLength;\\n    }\\n\\n    /**\\n     * @notice Get rounds list which has not yet had results processed\\n     */\\n\\n    function _getPendingResultRounds() internal view returns (Types.Round[] memory) {\\n        Types.Round[] memory tempRounds = new Types.Round[](_currentRoundId);\\n        uint256 count = 0;\\n        for (uint256 i = 1; i <= _currentRoundId; i++) {\\n            Types.Round memory round = _rounds[i];\\n            if (round.created && round.result == Types.Direction.DEFAULT) {\\n                tempRounds[count] = round;\\n                count++;\\n            }\\n        }\\n        // Allocate the exact-sized array\\n        Types.Round[] memory pendingRounds = new Types.Round[](count);\\n        for (uint256 j = 0; j < count; j++) {\\n            pendingRounds[j] = tempRounds[j];\\n        }\\n        return pendingRounds;\\n    }\\n}\\n"\r\n    },\r\n    "src/libraries/CalculatorHelper.sol": {\r\n      "content": "// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.20;\\n\\nimport { Types } from \\"libraries/Types.sol\\";\\n\\nlibrary CalculatorHelper {\\n    uint256 private constant PRECISION = 1e18;\\n\\n    function calculateRewardMultiplier(\\n        uint256 totalPool,\\n        uint256 directionPool,\\n        uint256 feePercentage\\n    ) internal pure returns (uint256) {\\n        if (directionPool == 0) return 0;\\n        uint256 netPool = calculateNetAmount(totalPool, feePercentage);\\n\\n        // Use fixed-point arithmetic to prevent precision loss\\n        uint256 multiplier = (netPool * PRECISION) / directionPool;\\n        return multiplier;\\n    }\\n\\n    function calculateRewardAmount(\\n        uint256 userAmount,\\n        uint256 totalPool, // total pool of the round fee will be deducted\\n        uint256 directionPool,\\n        uint256 feePercentage\\n    ) internal pure returns (uint256) {\\n        uint256 multiplier = calculateRewardMultiplier(totalPool, directionPool, feePercentage);\\n\\n        // Divide by PRECISION to get actual reward amount\\n        uint256 rewardAmount = (userAmount * multiplier) / PRECISION;\\n        return rewardAmount;\\n    }\\n\\n    function calculateNetAmount(uint256 amount, uint256 feePercentage) internal pure returns (uint256) {\\n        uint256 feeAmount = calculateFee(amount, feePercentage);\\n        return amount - feeAmount;\\n    }\\n\\n    function calculateFee(uint256 amount, uint256 feePercentage) internal pure returns (uint256) {\\n        uint256 feeAmount = (amount * feePercentage) / 100;\\n        return feeAmount;\\n    }\\n\\n    function determineRoundResult(Types.Round memory round) internal pure returns (Types.Direction) {\\n        uint256 startPrice = round.startPrice;\\n        uint256 endPrice = round.endPrice;\\n        uint256 upPool = round.upPool;\\n        uint256 downPool = round.downPool;\\n\\n        if (upPool == 0 && downPool == 0) {\\n            return Types.Direction.DRAW;\\n        } else if (upPool > 0 && downPool == 0) {\\n            return Types.Direction.DRAW;\\n        } else if (downPool > 0 && upPool == 0) {\\n            return Types.Direction.DRAW;\\n        } else if (endPrice > startPrice) {\\n            return Types.Direction.UP;\\n        } else if (endPrice < startPrice) {\\n            return Types.Direction.DOWN;\\n        } else {\\n            return Types.Direction.DRAW;\\n        }\\n    }\\n\\n    function determineTradeStatus(\\n        Types.TradeHistory memory trade,\\n        Types.Round memory round\\n    ) internal pure returns (Types.TradeStatus) {\\n        if (trade.sold) {\\n            return Types.TradeStatus.SOLD;\\n        } else if (round.endPrice > 0) {\\n            // Round has ended\\n            if (round.result == Types.Direction.DRAW) {\\n                return Types.TradeStatus.REFUNDED;\\n            } else if (trade.direction == round.result) {\\n                return Types.TradeStatus.WON;\\n            } else {\\n                return Types.TradeStatus.LOST;\\n            }\\n        } else {\\n            return Types.TradeStatus.ACTIVE;\\n        }\\n    }\\n\\n    function determineDirectionPool(\\n        Types.Round memory round,\\n        Types.Direction direction\\n    ) internal pure returns (uint256) {\\n        if (direction == Types.Direction.UP) {\\n            return round.upPool;\\n        } else if (direction == Types.Direction.DOWN) {\\n            return round.downPool;\\n        } else {\\n            return 0;\\n        }\\n    }\\n\\n    function calculateDistribution(\\n        Types.Round memory round,\\n        uint256 totalBets,\\n        uint256 feePercentage\\n    ) internal pure returns (Types.Distribution memory) {\\n        uint256 projectFee = calculateFee(round.totalPool, feePercentage);\\n        uint256 netPool = round.totalPool - projectFee;\\n        uint256 pendingDistribution = totalBets - round.distributedCount;\\n        return\\n            Types.Distribution({ projectFee: projectFee, netPool: netPool, pendingDistribution: pendingDistribution });\\n    }\\n\\n    function calculateBaseValue(\\n        uint256 betAmount,\\n        uint256 entryMultiplier,\\n        uint256 currentMultiplier\\n    ) internal pure returns (uint256 netSellPrice) {\\n        return (betAmount * entryMultiplier) / currentMultiplier;\\n    }\\n\\n    function calculateSellOutcome(\\n        Types.Round memory round,\\n        Types.Bet memory bet,\\n        uint256 feePercentage,\\n        uint256 sellFeePercentage\\n    ) internal pure returns (uint256, uint256, uint256) {\\n        uint256 directionPool = CalculatorHelper.determineDirectionPool(round, bet.direction);\\n        uint256 currentMultiplier = CalculatorHelper.calculateRewardMultiplier(\\n            round.totalPool,\\n            directionPool,\\n            feePercentage\\n        );\\n\\n        uint256 sellPrice = CalculatorHelper.calculateBaseValue(bet.amount, bet.entryMultiplier, currentMultiplier);\\n\\n        uint256 totalFee = CalculatorHelper.calculateFee(sellPrice, feePercentage + sellFeePercentage);\\n\\n        uint256 netSellAmount = sellPrice - totalFee;\\n        return (netSellAmount, totalFee, currentMultiplier);\\n    }\\n}\\n"\r\n    },\r\n    "src/utils/Events.sol": {\r\n      "content": "// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.20;\\n\\nimport { Types } from \\"libraries/Types.sol\\";\\n\\n/**\\n * @title Events\\n * @notice Centralized event definitions for the prediction market\\n * @dev All events emitted by the system are defined here\\n */\\nlibrary Events {\\n    event RoundCreated(\\n        uint256 indexed round,\\n        uint256 timestamp // time of round creation\\n    );\\n\\n    event RoundStarted(\\n        uint256 indexed round,\\n        uint256 startPrice,\\n        uint256 startTime,\\n        uint256 endTime,\\n        uint256 timestamp // time of round starting\\n    );\\n\\n    event RoundEnded(\\n        uint256 indexed round,\\n        uint256 endPrice,\\n        Types.Direction result,\\n        uint256 timestamp // time of round ending\\n    );\\n\\n    event BetPlaced(\\n        uint256 indexed roundId,\\n        address indexed user,\\n        uint256 amount,\\n        Types.Direction direction,\\n        uint256 entryMultiplier,\\n        uint256 timestamp\\n    );\\n\\n    // Batch event for gas optimization\\n    event BatchDistributed(\\n        uint256 indexed roundId,\\n        uint256 startIndex,\\n        uint256 endIndex,\\n        uint256 totalAmount,\\n        uint256 recipientCount,\\n        bool isRefund,\\n        uint256 timestamp\\n    );\\n\\n    event FeeCollected(uint256 indexed roundId, uint256 amount, uint256 timestamp);\\n\\n    event BetSold(\\n        uint256 indexed roundId,\\n        address indexed user,\\n        uint256 betIndex,\\n        uint256 originalAmount,\\n        uint256 sellAmount,\\n        uint256 entryMultiplier,\\n        uint256 currentMultiplier,\\n        uint256 timestamp\\n    );\\n}\\n"\r\n    },\r\n    "lib/openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol": {\r\n      "content": "// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.5.0) (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {IERC20} from \\"../IERC20.sol\\";\\nimport {IERC1363} from \\"../../../interfaces/IERC1363.sol\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC-20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    /**\\n     * @dev An operation with an ERC-20 token failed.\\n     */\\n    error SafeERC20FailedOperation(address token);\\n\\n    /**\\n     * @dev Indicates a failed `decreaseAllowance` request.\\n     */\\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\\n\\n    /**\\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        if (!_safeTransfer(token, to, value, true)) {\\n            revert SafeERC20FailedOperation(address(token));\\n        }\\n    }\\n\\n    /**\\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\\n     */\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        if (!_safeTransferFrom(token, from, to, value, true)) {\\n            revert SafeERC20FailedOperation(address(token));\\n        }\\n    }\\n\\n    /**\\n     * @dev Variant of {safeTransfer} that returns a bool instead of reverting if the operation is not successful.\\n     */\\n    function trySafeTransfer(IERC20 token, address to, uint256 value) internal returns (bool) {\\n        return _safeTransfer(token, to, value, false);\\n    }\\n\\n    /**\\n     * @dev Variant of {safeTransferFrom} that returns a bool instead of reverting if the operation is not successful.\\n     */\\n    function trySafeTransferFrom(IERC20 token, address from, address to, uint256 value) internal returns (bool) {\\n        return _safeTransferFrom(token, from, to, value, false);\\n    }\\n\\n    /**\\n     * @dev Increase the calling contract\'s allowance toward `spender` by `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     *\\n     * IMPORTANT: If the token implements ERC-7674 (ERC-20 with temporary allowance), and if the \\"client\\"\\n     * smart contract uses ERC-7674 to set temporary allowances, then the \\"client\\" smart contract should avoid using\\n     * this function. Performing a {safeIncreaseAllowance} or {safeDecreaseAllowance} operation on a token contract\\n     * that has a non-zero temporary allowance (for that particular owner-spender) will result in unexpected behavior.\\n     */\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 oldAllowance = token.allowance(address(this), spender);\\n        forceApprove(token, spender, oldAllowance + value);\\n    }\\n\\n    /**\\n     * @dev Decrease the calling contract\'s allowance toward `spender` by `requestedDecrease`. If `token` returns no\\n     * value, non-reverting calls are assumed to be successful.\\n     *\\n     * IMPORTANT: If the token implements ERC-7674 (ERC-20 with temporary allowance), and if the \\"client\\"\\n     * smart contract uses ERC-7674 to set temporary allowances, then the \\"client\\" smart contract should avoid using\\n     * this function. Performing a {safeIncreaseAllowance} or {safeDecreaseAllowance} operation on a token contract\\n     * that has a non-zero temporary allowance (for that particular owner-spender) will result in unexpected behavior.\\n     */\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\\n        unchecked {\\n            uint256 currentAllowance = token.allowance(address(this), spender);\\n            if (currentAllowance < requestedDecrease) {\\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\\n            }\\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\\n        }\\n    }\\n\\n    /**\\n     * @dev Set the calling contract\'s allowance toward `spender` to `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\\n     * to be set to zero before setting it to a non-zero value, such as USDT.\\n     *\\n     * NOTE: If the token implements ERC-7674, this function will not modify any temporary allowance. This function\\n     * only sets the \\"standard\\" allowance. Any temporary allowance will remain active, in addition to the value being\\n     * set here.\\n     */\\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\\n        if (!_safeApprove(token, spender, value, false)) {\\n            if (!_safeApprove(token, spender, 0, true)) revert SafeERC20FailedOperation(address(token));\\n            if (!_safeApprove(token, spender, value, true)) revert SafeERC20FailedOperation(address(token));\\n        }\\n    }\\n\\n    /**\\n     * @dev Performs an {ERC1363} transferAndCall, with a fallback to the simple {ERC20} transfer if the target has no\\n     * code. This can be used to implement an {ERC721}-like safe transfer that relies on {ERC1363} checks when\\n     * targeting contracts.\\n     *\\n     * Reverts if the returned value is other than `true`.\\n     */\\n    function transferAndCallRelaxed(IERC1363 token, address to, uint256 value, bytes memory data) internal {\\n        if (to.code.length == 0) {\\n            safeTransfer(token, to, value);\\n        } else if (!token.transferAndCall(to, value, data)) {\\n            revert SafeERC20FailedOperation(address(token));\\n        }\\n    }\\n\\n    /**\\n     * @dev Performs an {ERC1363} transferFromAndCall, with a fallback to the simple {ERC20} transferFrom if the target\\n     * has no code. This can be used to implement an {ERC721}-like safe transfer that relies on {ERC1363} checks when\\n     * targeting contracts.\\n     *\\n     * Reverts if the returned value is other than `true`.\\n     */\\n    function transferFromAndCallRelaxed(\\n        IERC1363 token,\\n        address from,\\n        address to,\\n        uint256 value,\\n        bytes memory data\\n    ) internal {\\n        if (to.code.length == 0) {\\n            safeTransferFrom(token, from, to, value);\\n        } else if (!token.transferFromAndCall(from, to, value, data)) {\\n            revert SafeERC20FailedOperation(address(token));\\n        }\\n    }\\n\\n    /**\\n     * @dev Performs an {ERC1363} approveAndCall, with a fallback to the simple {ERC20} approve if the target has no\\n     * code. This can be used to implement an {ERC721}-like safe transfer that rely on {ERC1363} checks when\\n     * targeting contracts.\\n     *\\n     * NOTE: When the recipient address (`to`) has no code (i.e. is an EOA), this function behaves as {forceApprove}.\\n     * Oppositely, when the recipient address (`to`) has code, this function only attempts to call {ERC1363-approveAndCall}\\n     * once without retrying, and relies on the returned value to be true.\\n     *\\n     * Reverts if the returned value is other than `true`.\\n     */\\n    function approveAndCallRelaxed(IERC1363 token, address to, uint256 value, bytes memory data) internal {\\n        if (to.code.length == 0) {\\n            forceApprove(token, to, value);\\n        } else if (!token.approveAndCall(to, value, data)) {\\n            revert SafeERC20FailedOperation(address(token));\\n        }\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity `token.transfer(to, value)` call, relaxing the requirement on the return value: the\\n     * return value is optional (but if data is returned, it must not be false).\\n     *\\n     * @param token The token targeted by the call.\\n     * @param to The recipient of the tokens\\n     * @param value The amount of token to transfer\\n     * @param bubble Behavior switch if the transfer call reverts: bubble the revert reason or return a false boolean.\\n     */\\n    function _safeTransfer(IERC20 token, address to, uint256 value, bool bubble) private returns (bool success) {\\n        bytes4 selector = IERC20.transfer.selector;\\n\\n        assembly (\\"memory-safe\\") {\\n            let fmp := mload(0x40)\\n            mstore(0x00, selector)\\n            mstore(0x04, and(to, shr(96, not(0))))\\n            mstore(0x24, value)\\n            success := call(gas(), token, 0, 0x00, 0x44, 0x00, 0x20)\\n            // if call success and return is true, all is good.\\n            // otherwise (not success or return is not true), we need to perform further checks\\n            if iszero(and(success, eq(mload(0x00), 1))) {\\n                // if the call was a failure and bubble is enabled, bubble the error\\n                if and(iszero(success), bubble) {\\n                    returndatacopy(fmp, 0x00, returndatasize())\\n                    revert(fmp, returndatasize())\\n                }\\n                // if the return value is not true, then the call is only successful if:\\n                // - the token address has code\\n                // - the returndata is empty\\n                success := and(success, and(iszero(returndatasize()), gt(extcodesize(token), 0)))\\n            }\\n            mstore(0x40, fmp)\\n        }\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity `token.transferFrom(from, to, value)` call, relaxing the requirement on the return\\n     * value: the return value is optional (but if data is returned, it must not be false).\\n     *\\n     * @param token The token targeted by the call.\\n     * @param from The sender of the tokens\\n     * @param to The recipient of the tokens\\n     * @param value The amount of token to transfer\\n     * @param bubble Behavior switch if the transfer call reverts: bubble the revert reason or return a false boolean.\\n     */\\n    function _safeTransferFrom(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 value,\\n        bool bubble\\n    ) private returns (bool success) {\\n        bytes4 selector = IERC20.transferFrom.selector;\\n\\n        assembly (\\"memory-safe\\") {\\n            let fmp := mload(0x40)\\n            mstore(0x00, selector)\\n            mstore(0x04, and(from, shr(96, not(0))))\\n            mstore(0x24, and(to, shr(96, not(0))))\\n            mstore(0x44, value)\\n            success := call(gas(), token, 0, 0x00, 0x64, 0x00, 0x20)\\n            // if call success and return is true, all is good.\\n            // otherwise (not success or return is not true), we need to perform further checks\\n            if iszero(and(success, eq(mload(0x00), 1))) {\\n                // if the call was a failure and bubble is enabled, bubble the error\\n                if and(iszero(success), bubble) {\\n                    returndatacopy(fmp, 0x00, returndatasize())\\n                    revert(fmp, returndatasize())\\n                }\\n                // if the return value is not true, then the call is only successful if:\\n                // - the token address has code\\n                // - the returndata is empty\\n                success := and(success, and(iszero(returndatasize()), gt(extcodesize(token), 0)))\\n            }\\n            mstore(0x40, fmp)\\n            mstore(0x60, 0)\\n        }\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity `token.approve(spender, value)` call, relaxing the requirement on the return value:\\n     * the return value is optional (but if data is returned, it must not be false).\\n     *\\n     * @param token The token targeted by the call.\\n     * @param spender The spender of the tokens\\n     * @param value The amount of token to transfer\\n     * @param bubble Behavior switch if the transfer call reverts: bubble the revert reason or return a false boolean.\\n     */\\n    function _safeApprove(IERC20 token, address spender, uint256 value, bool bubble) private returns (bool success) {\\n        bytes4 selector = IERC20.approve.selector;\\n\\n        assembly (\\"memory-safe\\") {\\n            let fmp := mload(0x40)\\n            mstore(0x00, selector)\\n            mstore(0x04, and(spender, shr(96, not(0))))\\n            mstore(0x24, value)\\n            success := call(gas(), token, 0, 0x00, 0x44, 0x00, 0x20)\\n            // if call success and return is true, all is good.\\n            // otherwise (not success or return is not true), we need to perform further checks\\n            if iszero(and(success, eq(mload(0x00), 1))) {\\n                // if the call was a failure and bubble is enabled, bubble the error\\n                if and(iszero(success), bubble) {\\n                    returndatacopy(fmp, 0x00, returndatasize())\\n                    revert(fmp, returndatasize())\\n                }\\n                // if the return value is not true, then the call is only successful if:\\n                // - the token address has code\\n                // - the returndata is empty\\n                success := and(success, and(iszero(returndatasize()), gt(extcodesize(token), 0)))\\n            }\\n            mstore(0x40, fmp)\\n        }\\n    }\\n}\\n"\r\n    },\r\n    "lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol": {\r\n      "content": "// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.4.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity >=0.4.16;\\n\\n/**\\n * @dev Interface of the ERC-20 standard as defined in the ERC.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the value of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the value of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from the caller\'s account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\\n     * caller\'s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\'s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\\n     * allowance mechanism. `value` is then deducted from the caller\'s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\\n}\\n"\r\n    },\r\n    "src/access/AdminControl.sol": {\r\n      "content": "// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.20;\\n\\nimport { Ownable } from \\"@openzeppelin/contracts/access/Ownable.sol\\";\\n\\n/**\\n * @title AdminControl\\n * @notice Access control for admin-only functions\\n * @dev Extends OpenZeppelin\'s Ownable with operator role\\n */\\nabstract contract AdminControl is Ownable {\\n    mapping(address => bool) private _operators;\\n\\n    event OperatorAdded(address indexed operator);\\n    event OperatorRemoved(address indexed operator);\\n\\n    /**\\n     * @notice Initializes the contract with an admin address\\n     * @param initialAdmin The address that will be set as the contract admin\\n     */\\n    constructor(address initialAdmin) Ownable(initialAdmin) {}\\n\\n    /**\\n     * @notice Modifier to restrict function to admin only\\n     */\\n    modifier onlyAdmin() {\\n        _requireAdmin();\\n        _;\\n    }\\n\\n    /**\\n     * @notice Modifier to restrict function to operators only\\n     */\\n    modifier onlyOperator() {\\n        _requireOperator();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Internal function to verify caller is the admin\\n     */\\n    function _requireAdmin() internal view {\\n        require(msg.sender == owner(), \\"AdminControl: caller is not admin\\");\\n    }\\n\\n    /**\\n     * @dev Internal function to verify caller is an operator or admin\\n     */\\n    function _requireOperator() internal view {\\n        require(_operators[msg.sender] || msg.sender == owner(), \\"AdminControl: caller is not operator\\");\\n    }\\n\\n    /**\\n     * @notice Adds an operator\\n     * @param operator The address to add as operator\\n     */\\n    function addOperator(address operator) external onlyAdmin {\\n        require(operator != address(0), \\"AdminControl: zero address\\");\\n        require(!_operators[operator], \\"AdminControl: already operator\\");\\n        _operators[operator] = true;\\n        emit OperatorAdded(operator);\\n    }\\n\\n    /**\\n     * @notice Removes an operator\\n     * @param operator The address to remove from operators\\n     */\\n    function removeOperator(address operator) external onlyAdmin {\\n        require(_operators[operator], \\"AdminControl: not an operator\\");\\n        _operators[operator] = false;\\n        emit OperatorRemoved(operator);\\n    }\\n\\n    /**\\n     * @notice Checks if an address is an operator\\n     * @param account The address to check\\n     * @return True if the address is an operator\\n     */\\n    function isOperator(address account) external view returns (bool) {\\n        return _operators[account] || account == owner();\\n    }\\n}\\n"\r\n    },\r\n    "src/access/EmergencyPause.sol": {\r\n      "content": "// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.20;\\n\\nimport { Pausable } from \\"@openzeppelin/contracts/utils/Pausable.sol\\";\\n\\n/**\\n * @title EmergencyPause\\n * @notice Emergency pause functionality for the prediction market\\n * @dev Allows pausing of critical functions in case of emergency\\n */\\nabstract contract EmergencyPause is Pausable {\\n    address private _pauser;\\n\\n    event PauserChanged(address indexed previousPauser, address indexed newPauser);\\n\\n    /**\\n     * @notice Initializes the contract with a pauser address\\n     * @param initialPauser The address that will be set as the contract pauser\\n     */\\n    constructor(address initialPauser) {\\n        require(initialPauser != address(0), \\"EmergencyPause: zero address\\");\\n        _pauser = initialPauser;\\n    }\\n\\n    /**\\n     * @notice Modifier to restrict function to pauser only\\n     */\\n    modifier onlyPauser() {\\n        _requirePauser();\\n        _;\\n    }\\n\\n    modifier onlyWhenNotPaused() {\\n        _requireNotPaused();\\n        _;\\n    }\\n\\n    /**\\n     * @notice Pauses all pausable functions\\n     */\\n    function pause() external onlyPauser {\\n        _pause();\\n    }\\n\\n    /**\\n     * @notice Unpauses all pausable functions\\n     */\\n    function unpause() external onlyPauser {\\n        _unpause();\\n    }\\n\\n    /**\\n     * @dev Internal function to verify caller is the pauser\\n     */\\n    function _requirePauser() internal view {\\n        require(msg.sender == _pauser, \\"EmergencyPause: caller is not pauser\\");\\n    }\\n\\n    function _requireNotPaused() internal view override {\\n        require(!paused(), \\"EmergencyPause: paused\\");\\n    }\\n\\n    /**\\n     * @notice Changes the pauser address\\n     * @param newPauser The new pauser address\\n     */\\n    function changePauser(address newPauser) external onlyPauser {\\n        require(newPauser != address(0), \\"EmergencyPause: zero address\\");\\n        address oldPauser = _pauser;\\n        _pauser = newPauser;\\n        emit PauserChanged(oldPauser, newPauser);\\n    }\\n\\n    /**\\n     * @notice Gets the current pauser address\\n     * @return The pauser address\\n     */\\n    function pauser() external view returns (address) {\\n        return _pauser;\\n    }\\n}\\n"\r\n    },\r\n    "src/access/ReentrancyGaurd.sol": {\r\n      "content": "// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.20;\\n\\nabstract contract ReentrancyGuard {\\n    uint256 private locked = 1;\\n\\n    modifier nonReentrant() {\\n        _nonReentrantBefore();\\n        _;\\n        _nonReentrantAfter();\\n    }\\n\\n    function _nonReentrantBefore() internal {\\n        _requireNotReentrant();\\n        locked = 2;\\n    }\\n\\n    function _nonReentrantAfter() internal {\\n        locked = 1;\\n    }\\n\\n    function _requireNotReentrant() internal view {\\n        require(locked == 1, \\"ReentrancyGuard: reentrant call\\");\\n    }\\n}\\n"\r\n    },\r\n    "lib/openzeppelin-contracts/contracts/interfaces/IERC1363.sol": {\r\n      "content": "// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.4.0) (interfaces/IERC1363.sol)\\n\\npragma solidity >=0.6.2;\\n\\nimport {IERC20} from \\"./IERC20.sol\\";\\nimport {IERC165} from \\"./IERC165.sol\\";\\n\\n/**\\n * @title IERC1363\\n * @dev Interface of the ERC-1363 standard as defined in the https://eips.ethereum.org/EIPS/eip-1363[ERC-1363].\\n *\\n * Defines an extension interface for ERC-20 tokens that supports executing code on a recipient contract\\n * after `transfer` or `transferFrom`, or code on a spender contract after `approve`, in a single transaction.\\n */\\ninterface IERC1363 is IERC20, IERC165 {\\n    /*\\n     * Note: the ERC-165 identifier for this interface is 0xb0202a11.\\n     * 0xb0202a11 ===\\n     *   bytes4(keccak256(\'transferAndCall(address,uint256)\')) ^\\n     *   bytes4(keccak256(\'transferAndCall(address,uint256,bytes)\')) ^\\n     *   bytes4(keccak256(\'transferFromAndCall(address,address,uint256)\')) ^\\n     *   bytes4(keccak256(\'transferFromAndCall(address,address,uint256,bytes)\')) ^\\n     *   bytes4(keccak256(\'approveAndCall(address,uint256)\')) ^\\n     *   bytes4(keccak256(\'approveAndCall(address,uint256,bytes)\'))\\n     */\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from the caller\'s account to `to`\\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\\n     * @param to The address which you want to transfer to.\\n     * @param value The amount of tokens to be transferred.\\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\\n     */\\n    function transferAndCall(address to, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from the caller\'s account to `to`\\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\\n     * @param to The address which you want to transfer to.\\n     * @param value The amount of tokens to be transferred.\\n     * @param data Additional data with no specified format, sent in call to `to`.\\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\\n     */\\n    function transferAndCall(address to, uint256 value, bytes calldata data) external returns (bool);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the allowance mechanism\\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\\n     * @param from The address which you want to send tokens from.\\n     * @param to The address which you want to transfer to.\\n     * @param value The amount of tokens to be transferred.\\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\\n     */\\n    function transferFromAndCall(address from, address to, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the allowance mechanism\\n     * and then calls {IERC1363Receiver-onTransferReceived} on `to`.\\n     * @param from The address which you want to send tokens from.\\n     * @param to The address which you want to transfer to.\\n     * @param value The amount of tokens to be transferred.\\n     * @param data Additional data with no specified format, sent in call to `to`.\\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\\n     */\\n    function transferFromAndCall(address from, address to, uint256 value, bytes calldata data) external returns (bool);\\n\\n    /**\\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\\n     * caller\'s tokens and then calls {IERC1363Spender-onApprovalReceived} on `spender`.\\n     * @param spender The address which will spend the funds.\\n     * @param value The amount of tokens to be spent.\\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\\n     */\\n    function approveAndCall(address spender, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\\n     * caller\'s tokens and then calls {IERC1363Spender-onApprovalReceived} on `spender`.\\n     * @param spender The address which will spend the funds.\\n     * @param value The amount of tokens to be spent.\\n     * @param data Additional data with no specified format, sent in call to `spender`.\\n     * @return A boolean value indicating whether the operation succeeded unless throwing.\\n     */\\n    function approveAndCall(address spender, uint256 value, bytes calldata data) external returns (bool);\\n}\\n"\r\n    },\r\n    "lib/openzeppelin-contracts/contracts/access/Ownable.sol": {\r\n      "content": "// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {Context} from \\"../utils/Context.sol\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * The initial owner is set to the address provided by the deployer. This can\\n * later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    /**\\n     * @dev The caller account is not authorized to perform an operation.\\n     */\\n    error OwnableUnauthorizedAccount(address account);\\n\\n    /**\\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\\n     */\\n    error OwnableInvalidOwner(address owner);\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\\n     */\\n    constructor(address initialOwner) {\\n        if (initialOwner == address(0)) {\\n            revert OwnableInvalidOwner(address(0));\\n        }\\n        _transferOwnership(initialOwner);\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        if (owner() != _msgSender()) {\\n            revert OwnableUnauthorizedAccount(_msgSender());\\n        }\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        if (newOwner == address(0)) {\\n            revert OwnableInvalidOwner(address(0));\\n        }\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n"\r\n    },\r\n    "lib/openzeppelin-contracts/contracts/utils/Pausable.sol": {\r\n      "content": "// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.3.0) (utils/Pausable.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {Context} from \\"../utils/Context.sol\\";\\n\\n/**\\n * @dev Contract module which allows children to implement an emergency stop\\n * mechanism that can be triggered by an authorized account.\\n *\\n * This module is used through inheritance. It will make available the\\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\\n * the functions of your contract. Note that they will not be pausable by\\n * simply including this module, only once the modifiers are put in place.\\n */\\nabstract contract Pausable is Context {\\n    bool private _paused;\\n\\n    /**\\n     * @dev Emitted when the pause is triggered by `account`.\\n     */\\n    event Paused(address account);\\n\\n    /**\\n     * @dev Emitted when the pause is lifted by `account`.\\n     */\\n    event Unpaused(address account);\\n\\n    /**\\n     * @dev The operation failed because the contract is paused.\\n     */\\n    error EnforcedPause();\\n\\n    /**\\n     * @dev The operation failed because the contract is not paused.\\n     */\\n    error ExpectedPause();\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    modifier whenNotPaused() {\\n        _requireNotPaused();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    modifier whenPaused() {\\n        _requirePaused();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns true if the contract is paused, and false otherwise.\\n     */\\n    function paused() public view virtual returns (bool) {\\n        return _paused;\\n    }\\n\\n    /**\\n     * @dev Throws if the contract is paused.\\n     */\\n    function _requireNotPaused() internal view virtual {\\n        if (paused()) {\\n            revert EnforcedPause();\\n        }\\n    }\\n\\n    /**\\n     * @dev Throws if the contract is not paused.\\n     */\\n    function _requirePaused() internal view virtual {\\n        if (!paused()) {\\n            revert ExpectedPause();\\n        }\\n    }\\n\\n    /**\\n     * @dev Triggers stopped state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    function _pause() internal virtual whenNotPaused {\\n        _paused = true;\\n        emit Paused(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns to normal state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    function _unpause() internal virtual whenPaused {\\n        _paused = false;\\n        emit Unpaused(_msgSender());\\n    }\\n}\\n"\r\n    },\r\n    "lib/openzeppelin-contracts/contracts/interfaces/IERC20.sol": {\r\n      "content": "// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.4.0) (interfaces/IERC20.sol)\\n\\npragma solidity >=0.4.16;\\n\\nimport {IERC20} from \\"../token/ERC20/IERC20.sol\\";\\n"\r\n    },\r\n    "lib/openzeppelin-contracts/contracts/interfaces/IERC165.sol": {\r\n      "content": "// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.4.0) (interfaces/IERC165.sol)\\n\\npragma solidity >=0.4.16;\\n\\nimport {IERC165} from \\"../utils/introspection/IERC165.sol\\";\\n"\r\n    },\r\n    "lib/openzeppelin-contracts/contracts/utils/Context.sol": {\r\n      "content": "// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n\\n    function _contextSuffixLength() internal view virtual returns (uint256) {\\n        return 0;\\n    }\\n}\\n"\r\n    },\r\n    "lib/openzeppelin-contracts/contracts/utils/introspection/IERC165.sol": {\r\n      "content": "// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.4.0) (utils/introspection/IERC165.sol)\\n\\npragma solidity >=0.4.16;\\n\\n/**\\n * @dev Interface of the ERC-165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[ERC].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[ERC section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n"\r\n    }\r\n  },\r\n  "settings": {\r\n    "remappings": [\r\n      "@openzeppelin/=lib/openzeppelin-contracts/",\r\n      "libraries/=src/libraries/",\r\n      "utils/=src/utils/",\r\n      "core/=src/core/",\r\n      "access/=src/access/",\r\n      "mock/=src/mock/",\r\n      "dev/=src/dev/",\r\n      "erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/",\r\n      "forge-std/=lib/forge-std/src/",\r\n      "halmos-cheatcodes/=lib/openzeppelin-contracts/lib/halmos-cheatcodes/src/",\r\n      "openzeppelin-contracts/=lib/openzeppelin-contracts/"\r\n    ],\r\n    "optimizer": {\r\n      "enabled": true,\r\n      "runs": 200\r\n    },\r\n    "metadata": {\r\n      "useLiteralContent": false,\r\n      "bytecodeHash": "ipfs",\r\n      "appendCBOR": true\r\n    },\r\n    "outputSelection": {\r\n      "*": {\r\n        "*": [\r\n          "evm.bytecode",\r\n          "evm.deployedBytecode",\r\n          "devdoc",\r\n          "userdoc",\r\n          "metadata",\r\n          "abi"\r\n        ]\r\n      }\r\n    },\r\n    "evmVersion": "prague",\r\n    "viaIR": true\r\n  }\r\n}}',
                ABI: '[{"inputs":[{"internalType":"address","name":"adminAddress","type":"address"},{"internalType":"address","name":"tokenAddress","type":"address"}],"stateMutability":"nonpayable","type":"constructor"},{"inputs":[],"name":"EnforcedPause","type":"error"},{"inputs":[],"name":"ExpectedPause","type":"error"},{"inputs":[{"internalType":"address","name":"owner","type":"address"}],"name":"OwnableInvalidOwner","type":"error"},{"inputs":[{"internalType":"address","name":"account","type":"address"}],"name":"OwnableUnauthorizedAccount","type":"error"},{"inputs":[{"internalType":"address","name":"token","type":"address"}],"name":"SafeERC20FailedOperation","type":"error"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"uint256","name":"roundId","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"startIndex","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"endIndex","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"totalAmount","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"recipientCount","type":"uint256"},{"indexed":false,"internalType":"bool","name":"isRefund","type":"bool"},{"indexed":false,"internalType":"uint256","name":"timestamp","type":"uint256"}],"name":"BatchDistributed","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"uint256","name":"roundId","type":"uint256"},{"indexed":true,"internalType":"address","name":"user","type":"address"},{"indexed":false,"internalType":"uint256","name":"amount","type":"uint256"},{"indexed":false,"internalType":"enum Types.Direction","name":"direction","type":"uint8"},{"indexed":false,"internalType":"uint256","name":"entryMultiplier","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"timestamp","type":"uint256"}],"name":"BetPlaced","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"uint256","name":"roundId","type":"uint256"},{"indexed":true,"internalType":"address","name":"user","type":"address"},{"indexed":false,"internalType":"uint256","name":"betIndex","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"originalAmount","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"sellAmount","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"entryMultiplier","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"currentMultiplier","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"timestamp","type":"uint256"}],"name":"BetSold","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"uint256","name":"roundId","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"amount","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"timestamp","type":"uint256"}],"name":"FeeCollected","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"operator","type":"address"}],"name":"OperatorAdded","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"operator","type":"address"}],"name":"OperatorRemoved","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"previousOwner","type":"address"},{"indexed":true,"internalType":"address","name":"newOwner","type":"address"}],"name":"OwnershipTransferred","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"account","type":"address"}],"name":"Paused","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"previousPauser","type":"address"},{"indexed":true,"internalType":"address","name":"newPauser","type":"address"}],"name":"PauserChanged","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"uint256","name":"round","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"timestamp","type":"uint256"}],"name":"RoundCreated","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"uint256","name":"round","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"endPrice","type":"uint256"},{"indexed":false,"internalType":"enum Types.Direction","name":"result","type":"uint8"},{"indexed":false,"internalType":"uint256","name":"timestamp","type":"uint256"}],"name":"RoundEnded","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"uint256","name":"round","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"startPrice","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"startTime","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"endTime","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"timestamp","type":"uint256"}],"name":"RoundStarted","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"account","type":"address"}],"name":"Unpaused","type":"event"},{"inputs":[],"name":"MAX_FEE_PERCENTAGE","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"operator","type":"address"}],"name":"addOperator","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"roundId","type":"uint256"},{"internalType":"uint256","name":"amount","type":"uint256"},{"internalType":"enum Types.Direction","name":"direction","type":"uint8"}],"name":"calculatePotentialPayout","outputs":[{"internalType":"uint256","name":"potentialPayout","type":"uint256"},{"internalType":"uint256","name":"currentMultiplier","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"newPauser","type":"address"}],"name":"changePauser","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"components":[{"internalType":"uint256","name":"minBetAmount","type":"uint256"},{"internalType":"uint256","name":"maxBetAmount","type":"uint256"},{"internalType":"uint256","name":"betsLimit","type":"uint256"}],"internalType":"struct Types.NewRound","name":"newRound","type":"tuple"}],"name":"createRound","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"roundId","type":"uint256"},{"internalType":"uint256","name":"endPrice","type":"uint256"},{"internalType":"uint256","name":"batchSize","type":"uint256"}],"name":"endRound","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"feePercentage","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"user","type":"address"}],"name":"getActiveBetsForUser","outputs":[{"components":[{"internalType":"uint256","name":"tradeIndex","type":"uint256"},{"internalType":"uint256","name":"betIndex","type":"uint256"},{"internalType":"address","name":"user","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"},{"internalType":"enum Types.Direction","name":"direction","type":"uint8"},{"internalType":"bool","name":"sold","type":"bool"},{"internalType":"uint256","name":"sellAmount","type":"uint256"},{"internalType":"uint256","name":"entryMultiplier","type":"uint256"},{"internalType":"uint256","name":"currentMultiplier","type":"uint256"},{"internalType":"uint256","name":"currentValue","type":"uint256"}],"internalType":"struct Types.BetView[]","name":"","type":"tuple[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"roundId","type":"uint256"},{"internalType":"address","name":"user","type":"address"}],"name":"getActiveBetsForUserInRound","outputs":[{"components":[{"internalType":"uint256","name":"tradeIndex","type":"uint256"},{"internalType":"uint256","name":"betIndex","type":"uint256"},{"internalType":"address","name":"user","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"},{"internalType":"enum Types.Direction","name":"direction","type":"uint8"},{"internalType":"bool","name":"sold","type":"bool"},{"internalType":"uint256","name":"sellAmount","type":"uint256"},{"internalType":"uint256","name":"entryMultiplier","type":"uint256"},{"internalType":"uint256","name":"currentMultiplier","type":"uint256"},{"internalType":"uint256","name":"currentValue","type":"uint256"}],"internalType":"struct Types.BetView[]","name":"","type":"tuple[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"roundId","type":"uint256"},{"internalType":"uint256","name":"betIndex","type":"uint256"}],"name":"getBet","outputs":[{"components":[{"internalType":"address","name":"user","type":"address"},{"internalType":"uint256","name":"tradeIndex","type":"uint256"},{"internalType":"uint256","name":"amount","type":"uint256"},{"internalType":"enum Types.Direction","name":"direction","type":"uint8"},{"internalType":"bool","name":"sold","type":"bool"},{"internalType":"uint256","name":"sellAmount","type":"uint256"},{"internalType":"uint256","name":"entryMultiplier","type":"uint256"}],"internalType":"struct Types.Bet","name":"","type":"tuple"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getConfiguration","outputs":[{"internalType":"address","name":"tokenAddress","type":"address"},{"internalType":"uint256","name":"feePercent","type":"uint256"},{"internalType":"uint256","name":"sellFeePercent","type":"uint256"},{"internalType":"uint256","name":"maxFeePercent","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getCurrentRound","outputs":[{"components":[{"internalType":"uint256","name":"round","type":"uint256"},{"internalType":"uint256","name":"startPrice","type":"uint256"},{"internalType":"uint256","name":"endPrice","type":"uint256"},{"internalType":"uint256","name":"minBetAmount","type":"uint256"},{"internalType":"uint256","name":"maxBetAmount","type":"uint256"},{"internalType":"uint256","name":"totalPool","type":"uint256"},{"internalType":"uint256","name":"upPool","type":"uint256"},{"internalType":"uint256","name":"downPool","type":"uint256"},{"internalType":"enum Types.Direction","name":"result","type":"uint8"},{"internalType":"uint256","name":"startTime","type":"uint256"},{"internalType":"uint256","name":"endTime","type":"uint256"},{"internalType":"uint256","name":"distributedCount","type":"uint256"},{"internalType":"uint256","name":"totalDistributed","type":"uint256"},{"internalType":"uint256","name":"betsLimit","type":"uint256"},{"internalType":"bool","name":"created","type":"bool"},{"internalType":"uint256","name":"createdAt","type":"uint256"}],"internalType":"struct Types.Round","name":"","type":"tuple"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getCurrentRoundId","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"roundId","type":"uint256"}],"name":"getDistributionStatus","outputs":[{"internalType":"bool","name":"isComplete","type":"bool"},{"internalType":"uint256","name":"distributedCount","type":"uint256"},{"internalType":"uint256","name":"totalBets","type":"uint256"},{"internalType":"uint256","name":"totalDistributed","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"limit","type":"uint256"}],"name":"getLeaderboard","outputs":[{"components":[{"internalType":"address","name":"user","type":"address"},{"internalType":"uint256","name":"totalBets","type":"uint256"},{"internalType":"uint256","name":"totalWins","type":"uint256"},{"internalType":"uint256","name":"totalAmountBet","type":"uint256"},{"internalType":"uint256","name":"totalAmountWon","type":"uint256"},{"internalType":"bool","name":"exists","type":"bool"}],"internalType":"struct Types.UserStats[]","name":"","type":"tuple[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"roundId","type":"uint256"}],"name":"getPendingDistribution","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getPendingResultRounds","outputs":[{"components":[{"internalType":"uint256","name":"round","type":"uint256"},{"internalType":"uint256","name":"startPrice","type":"uint256"},{"internalType":"uint256","name":"endPrice","type":"uint256"},{"internalType":"uint256","name":"minBetAmount","type":"uint256"},{"internalType":"uint256","name":"maxBetAmount","type":"uint256"},{"internalType":"uint256","name":"totalPool","type":"uint256"},{"internalType":"uint256","name":"upPool","type":"uint256"},{"internalType":"uint256","name":"downPool","type":"uint256"},{"internalType":"enum Types.Direction","name":"result","type":"uint8"},{"internalType":"uint256","name":"startTime","type":"uint256"},{"internalType":"uint256","name":"endTime","type":"uint256"},{"internalType":"uint256","name":"distributedCount","type":"uint256"},{"internalType":"uint256","name":"totalDistributed","type":"uint256"},{"internalType":"uint256","name":"betsLimit","type":"uint256"},{"internalType":"bool","name":"created","type":"bool"},{"internalType":"uint256","name":"createdAt","type":"uint256"}],"internalType":"struct Types.Round[]","name":"","type":"tuple[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"roundId","type":"uint256"}],"name":"getResult","outputs":[{"internalType":"enum Types.Direction","name":"","type":"uint8"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"roundId","type":"uint256"}],"name":"getRound","outputs":[{"components":[{"internalType":"uint256","name":"round","type":"uint256"},{"internalType":"uint256","name":"startPrice","type":"uint256"},{"internalType":"uint256","name":"endPrice","type":"uint256"},{"internalType":"uint256","name":"minBetAmount","type":"uint256"},{"internalType":"uint256","name":"maxBetAmount","type":"uint256"},{"internalType":"uint256","name":"totalPool","type":"uint256"},{"internalType":"uint256","name":"upPool","type":"uint256"},{"internalType":"uint256","name":"downPool","type":"uint256"},{"internalType":"enum Types.Direction","name":"result","type":"uint8"},{"internalType":"uint256","name":"startTime","type":"uint256"},{"internalType":"uint256","name":"endTime","type":"uint256"},{"internalType":"uint256","name":"distributedCount","type":"uint256"},{"internalType":"uint256","name":"totalDistributed","type":"uint256"},{"internalType":"uint256","name":"betsLimit","type":"uint256"},{"internalType":"bool","name":"created","type":"bool"},{"internalType":"uint256","name":"createdAt","type":"uint256"}],"internalType":"struct Types.Round","name":"","type":"tuple"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"roundId","type":"uint256"}],"name":"getRoundBetCount","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"roundId","type":"uint256"}],"name":"getRoundBets","outputs":[{"components":[{"internalType":"address","name":"user","type":"address"},{"internalType":"uint256","name":"tradeIndex","type":"uint256"},{"internalType":"uint256","name":"amount","type":"uint256"},{"internalType":"enum Types.Direction","name":"direction","type":"uint8"},{"internalType":"bool","name":"sold","type":"bool"},{"internalType":"uint256","name":"sellAmount","type":"uint256"},{"internalType":"uint256","name":"entryMultiplier","type":"uint256"}],"internalType":"struct Types.Bet[]","name":"","type":"tuple[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"roundId","type":"uint256"}],"name":"getRoundPools","outputs":[{"internalType":"uint256","name":"totalPool","type":"uint256"},{"internalType":"uint256","name":"upPool","type":"uint256"},{"internalType":"uint256","name":"downPool","type":"uint256"},{"internalType":"uint256","name":"upMultiplier","type":"uint256"},{"internalType":"uint256","name":"downMultiplier","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getTotalUsers","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"user","type":"address"}],"name":"getUserActiveTrades","outputs":[{"components":[{"internalType":"uint256","name":"roundId","type":"uint256"},{"internalType":"uint256","name":"amount","type":"uint256"},{"internalType":"enum Types.Direction","name":"direction","type":"uint8"},{"internalType":"enum Types.Direction","name":"result","type":"uint8"},{"internalType":"uint256","name":"entryMultiplier","type":"uint256"},{"internalType":"uint256","name":"timestamp","type":"uint256"},{"internalType":"uint256","name":"betIndex","type":"uint256"},{"internalType":"enum Types.TradeStatus","name":"status","type":"uint8"},{"internalType":"uint256","name":"payout","type":"uint256"},{"internalType":"uint256","name":"startPrice","type":"uint256"},{"internalType":"uint256","name":"endPrice","type":"uint256"}],"internalType":"struct Types.TradeHistoryView[]","name":"","type":"tuple[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"user","type":"address"}],"name":"getUserStats","outputs":[{"components":[{"internalType":"address","name":"user","type":"address"},{"internalType":"uint256","name":"totalBets","type":"uint256"},{"internalType":"uint256","name":"totalWins","type":"uint256"},{"internalType":"uint256","name":"totalAmountBet","type":"uint256"},{"internalType":"uint256","name":"totalAmountWon","type":"uint256"},{"internalType":"bool","name":"exists","type":"bool"}],"internalType":"struct Types.UserStats","name":"","type":"tuple"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"user","type":"address"}],"name":"getUserTradeCount","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"user","type":"address"},{"internalType":"uint256","name":"offset","type":"uint256"},{"internalType":"uint256","name":"limit","type":"uint256"}],"name":"getUserTradeHistory","outputs":[{"components":[{"internalType":"uint256","name":"roundId","type":"uint256"},{"internalType":"uint256","name":"amount","type":"uint256"},{"internalType":"enum Types.Direction","name":"direction","type":"uint8"},{"internalType":"enum Types.Direction","name":"result","type":"uint8"},{"internalType":"uint256","name":"entryMultiplier","type":"uint256"},{"internalType":"uint256","name":"timestamp","type":"uint256"},{"internalType":"uint256","name":"betIndex","type":"uint256"},{"internalType":"enum Types.TradeStatus","name":"status","type":"uint8"},{"internalType":"uint256","name":"payout","type":"uint256"},{"internalType":"uint256","name":"startPrice","type":"uint256"},{"internalType":"uint256","name":"endPrice","type":"uint256"}],"internalType":"struct Types.TradeHistoryView[]","name":"","type":"tuple[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"user","type":"address"},{"internalType":"uint256","name":"roundId","type":"uint256"}],"name":"getUserTradesByRound","outputs":[{"components":[{"internalType":"uint256","name":"roundId","type":"uint256"},{"internalType":"uint256","name":"amount","type":"uint256"},{"internalType":"enum Types.Direction","name":"direction","type":"uint8"},{"internalType":"enum Types.Direction","name":"result","type":"uint8"},{"internalType":"uint256","name":"entryMultiplier","type":"uint256"},{"internalType":"uint256","name":"timestamp","type":"uint256"},{"internalType":"uint256","name":"betIndex","type":"uint256"},{"internalType":"enum Types.TradeStatus","name":"status","type":"uint8"},{"internalType":"uint256","name":"payout","type":"uint256"},{"internalType":"uint256","name":"startPrice","type":"uint256"},{"internalType":"uint256","name":"endPrice","type":"uint256"}],"internalType":"struct Types.TradeHistoryView[]","name":"","type":"tuple[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"roundId","type":"uint256"}],"name":"isDistributionComplete","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"account","type":"address"}],"name":"isOperator","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"owner","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"pause","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"paused","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"pauser","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"roundId","type":"uint256"},{"internalType":"uint256","name":"amount","type":"uint256"},{"internalType":"enum Types.Direction","name":"direction","type":"uint8"}],"name":"placeBet","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"operator","type":"address"}],"name":"removeOperator","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"renounceOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"sellFeePercentage","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"roundId","type":"uint256"},{"internalType":"uint256","name":"betIndex","type":"uint256"}],"name":"sellPosition","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"newFeePercentage","type":"uint256"}],"name":"setFeePercentage","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"newSellFeePercentage","type":"uint256"}],"name":"setSellFeePercentage","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"tokenAddress","type":"address"}],"name":"setTokenAddress","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"roundId","type":"uint256"},{"components":[{"internalType":"uint256","name":"startPrice","type":"uint256"},{"internalType":"uint256","name":"startTime","type":"uint256"},{"internalType":"uint256","name":"endTime","type":"uint256"}],"internalType":"struct Types.RoundStartParams","name":"params","type":"tuple"}],"name":"startRound","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"token","outputs":[{"internalType":"contract IERC20","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"newOwner","type":"address"}],"name":"transferOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"unpause","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"amount","type":"uint256"},{"internalType":"address payable","name":"to","type":"address"}],"name":"withdrawETH","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"amount","type":"uint256"},{"internalType":"address","name":"to","type":"address"}],"name":"withdrawToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"stateMutability":"payable","type":"receive"}]',
                ContractName: 'UpDownPrediction',
                CompilerVersion: 'v0.8.30+commit.73712a01',
                CompilerType: 'solc-j',
                OptimizationUsed: '1',
                Runs: '200',
                ConstructorArguments:
                    '000000000000000000000000620fc409a1a55572cd9268dfc94f1a89e4c72dd10000000000000000000000004129f5924f53e621f07296045b1fbed35c803940',
                EVMVersion: 'prague',
                Library: '',
                ContractFileName: 'src/UpDownPrediction.sol',
                LicenseType: '',
                Proxy: '0',
                Implementation: '',
                SwarmSource: '',
                SimilarMatch: '',
            },
        ],
    };

    return <></>;
}
